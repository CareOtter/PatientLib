
//------------------------------------------------------------------------------
// This code was generated by a tool.
//
//   Tool : Bond Compiler 0.3.0.5
//   File : Content_types.h
//
// Changes to this file may cause incorrect behavior and will be lost when
// the code is regenerated.
// <auto-generated />
//------------------------------------------------------------------------------

#pragma once

#include <bond/core/bond_version.h>

#if BOND_VERSION < 0x302
#error This file was generated by a newer version of Bond compiler
#error and is incompatible with your version Bond library.
#endif

#if BOND_MIN_CODEGEN_VERSION > 0x0305
#error This file was generated by an older version of Bond compiler
#error and is incompatible with your version Bond library.
#endif

#include <bond/core/config.h>
#include <bond/core/containers.h>


#include "BaseClasses_types.h"

namespace HealthCare
{
namespace Schemas
{
    
    struct AdministrationRouteAndForm
    {
        bond::maybe<bond::nullable<std::string> > Form;
        bond::maybe<bond::nullable<std::string> > Route;
        
        AdministrationRouteAndForm()
        {
        }

        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated copy ctor OK
        AdministrationRouteAndForm(const AdministrationRouteAndForm& other) = default;
#endif
        
#ifndef BOND_NO_CXX11_RVALUE_REFERENCES
        AdministrationRouteAndForm(AdministrationRouteAndForm&& other)
          : Form(std::move(other.Form)),
            Route(std::move(other.Route))
        {
        }
#endif
        
        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated operator= OK
        AdministrationRouteAndForm& operator=(const AdministrationRouteAndForm& other) = default;
#endif

        bool operator==(const AdministrationRouteAndForm& other) const
        {
            return true
                && (Form == other.Form)
                && (Route == other.Route);
        }

        bool operator!=(const AdministrationRouteAndForm& other) const
        {
            return !(*this == other);
        }

        void swap(AdministrationRouteAndForm& other)
        {
            using std::swap;
            swap(Form, other.Form);
            swap(Route, other.Route);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(AdministrationRouteAndForm& left, AdministrationRouteAndForm& right)
    {
        left.swap(right);
    }

    
    struct MedicationContentItem
    {
        bond::maybe<bond::nullable<std::string> > NDC;
        bond::maybe<bond::nullable<std::string> > RxNorm;
        bond::maybe<bond::nullable<std::string> > MedicalName;
        bond::maybe<bond::nullable<std::string> > CommonName;
        bond::maybe<bond::nullable<std::string> > Strength;
        bond::maybe<std::vector< ::HealthCare::Schemas::AdministrationRouteAndForm> > AdministrationRouteAndForms;
        
        MedicationContentItem()
        {
        }

        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated copy ctor OK
        MedicationContentItem(const MedicationContentItem& other) = default;
#endif
        
#ifndef BOND_NO_CXX11_RVALUE_REFERENCES
        MedicationContentItem(MedicationContentItem&& other)
          : NDC(std::move(other.NDC)),
            RxNorm(std::move(other.RxNorm)),
            MedicalName(std::move(other.MedicalName)),
            CommonName(std::move(other.CommonName)),
            Strength(std::move(other.Strength)),
            AdministrationRouteAndForms(std::move(other.AdministrationRouteAndForms))
        {
        }
#endif
        
        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated operator= OK
        MedicationContentItem& operator=(const MedicationContentItem& other) = default;
#endif

        bool operator==(const MedicationContentItem& other) const
        {
            return true
                && (NDC == other.NDC)
                && (RxNorm == other.RxNorm)
                && (MedicalName == other.MedicalName)
                && (CommonName == other.CommonName)
                && (Strength == other.Strength)
                && (AdministrationRouteAndForms == other.AdministrationRouteAndForms);
        }

        bool operator!=(const MedicationContentItem& other) const
        {
            return !(*this == other);
        }

        void swap(MedicationContentItem& other)
        {
            using std::swap;
            swap(NDC, other.NDC);
            swap(RxNorm, other.RxNorm);
            swap(MedicalName, other.MedicalName);
            swap(CommonName, other.CommonName);
            swap(Strength, other.Strength);
            swap(AdministrationRouteAndForms, other.AdministrationRouteAndForms);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(MedicationContentItem& left, MedicationContentItem& right)
    {
        left.swap(right);
    }

    
    struct FrequencyContentItem
    {
        bond::maybe<bond::nullable<std::string> > Snomed;
        bond::maybe<bond::nullable<int64_t> > MaxDosesPerDay;
        bond::maybe<bond::nullable<std::string> > FrequencyText;
        
        FrequencyContentItem()
        {
        }

        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated copy ctor OK
        FrequencyContentItem(const FrequencyContentItem& other) = default;
#endif
        
#ifndef BOND_NO_CXX11_RVALUE_REFERENCES
        FrequencyContentItem(FrequencyContentItem&& other)
          : Snomed(std::move(other.Snomed)),
            MaxDosesPerDay(std::move(other.MaxDosesPerDay)),
            FrequencyText(std::move(other.FrequencyText))
        {
        }
#endif
        
        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated operator= OK
        FrequencyContentItem& operator=(const FrequencyContentItem& other) = default;
#endif

        bool operator==(const FrequencyContentItem& other) const
        {
            return true
                && (Snomed == other.Snomed)
                && (MaxDosesPerDay == other.MaxDosesPerDay)
                && (FrequencyText == other.FrequencyText);
        }

        bool operator!=(const FrequencyContentItem& other) const
        {
            return !(*this == other);
        }

        void swap(FrequencyContentItem& other)
        {
            using std::swap;
            swap(Snomed, other.Snomed);
            swap(MaxDosesPerDay, other.MaxDosesPerDay);
            swap(FrequencyText, other.FrequencyText);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(FrequencyContentItem& left, FrequencyContentItem& right)
    {
        left.swap(right);
    }

    
    struct SigInstructionContentItem
    {
        bond::maybe<bond::nullable<std::string> > Sig;
        
        SigInstructionContentItem()
        {
        }

        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated copy ctor OK
        SigInstructionContentItem(const SigInstructionContentItem& other) = default;
#endif
        
#ifndef BOND_NO_CXX11_RVALUE_REFERENCES
        SigInstructionContentItem(SigInstructionContentItem&& other)
          : Sig(std::move(other.Sig))
        {
        }
#endif
        
        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated operator= OK
        SigInstructionContentItem& operator=(const SigInstructionContentItem& other) = default;
#endif

        bool operator==(const SigInstructionContentItem& other) const
        {
            return true
                && (Sig == other.Sig);
        }

        bool operator!=(const SigInstructionContentItem& other) const
        {
            return !(*this == other);
        }

        void swap(SigInstructionContentItem& other)
        {
            using std::swap;
            swap(Sig, other.Sig);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(SigInstructionContentItem& left, SigInstructionContentItem& right)
    {
        left.swap(right);
    }

    
    struct OrderContentItem
    {
        bond::maybe<bond::nullable<std::string> > Name;
        bond::maybe<std::vector< ::HealthCare::Schemas::Nomenclature> > Nomenclatures;
        
        OrderContentItem()
        {
        }

        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated copy ctor OK
        OrderContentItem(const OrderContentItem& other) = default;
#endif
        
#ifndef BOND_NO_CXX11_RVALUE_REFERENCES
        OrderContentItem(OrderContentItem&& other)
          : Name(std::move(other.Name)),
            Nomenclatures(std::move(other.Nomenclatures))
        {
        }
#endif
        
        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated operator= OK
        OrderContentItem& operator=(const OrderContentItem& other) = default;
#endif

        bool operator==(const OrderContentItem& other) const
        {
            return true
                && (Name == other.Name)
                && (Nomenclatures == other.Nomenclatures);
        }

        bool operator!=(const OrderContentItem& other) const
        {
            return !(*this == other);
        }

        void swap(OrderContentItem& other)
        {
            using std::swap;
            swap(Name, other.Name);
            swap(Nomenclatures, other.Nomenclatures);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(OrderContentItem& left, OrderContentItem& right)
    {
        left.swap(right);
    }

    
    struct AllergyContentItem
    {
        bond::maybe<bond::nullable<std::string> > Name;
        bond::maybe<std::vector< ::HealthCare::Schemas::Nomenclature> > Nomenclatures;
        
        AllergyContentItem()
        {
        }

        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated copy ctor OK
        AllergyContentItem(const AllergyContentItem& other) = default;
#endif
        
#ifndef BOND_NO_CXX11_RVALUE_REFERENCES
        AllergyContentItem(AllergyContentItem&& other)
          : Name(std::move(other.Name)),
            Nomenclatures(std::move(other.Nomenclatures))
        {
        }
#endif
        
        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated operator= OK
        AllergyContentItem& operator=(const AllergyContentItem& other) = default;
#endif

        bool operator==(const AllergyContentItem& other) const
        {
            return true
                && (Name == other.Name)
                && (Nomenclatures == other.Nomenclatures);
        }

        bool operator!=(const AllergyContentItem& other) const
        {
            return !(*this == other);
        }

        void swap(AllergyContentItem& other)
        {
            using std::swap;
            swap(Name, other.Name);
            swap(Nomenclatures, other.Nomenclatures);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(AllergyContentItem& left, AllergyContentItem& right)
    {
        left.swap(right);
    }
} // namespace Schemas
} // namespace HealthCare

