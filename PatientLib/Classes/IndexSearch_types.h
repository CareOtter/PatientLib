
//------------------------------------------------------------------------------
// This code was generated by a tool.
//
//   Tool : Bond Compiler 0.3.0.5
//   File : IndexSearch_types.h
//
// Changes to this file may cause incorrect behavior and will be lost when
// the code is regenerated.
// <auto-generated />
//------------------------------------------------------------------------------

#pragma once

#include <bond/core/bond_version.h>

#if BOND_VERSION < 0x302
#error This file was generated by a newer version of Bond compiler
#error and is incompatible with your version Bond library.
#endif

#if BOND_MIN_CODEGEN_VERSION > 0x0305
#error This file was generated by an older version of Bond compiler
#error and is incompatible with your version Bond library.
#endif

#include <bond/core/config.h>
#include <bond/core/containers.h>
#include <bond/core/nullable.h>
#include <bond/core/bonded.h>


namespace HealthCare
{
namespace Schemas
{
namespace Index
{
    struct ViewCollection;

    
    struct IndexedProperty
    {
        bond::maybe<bond::nullable<std::string> > SearchTerm;
        bond::maybe<bond::nullable<std::string> > Value;
        std::vector<std::string> Conditionals;
        
        IndexedProperty()
        {
        }

        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated copy ctor OK
        IndexedProperty(const IndexedProperty& other) = default;
#endif
        
#ifndef BOND_NO_CXX11_RVALUE_REFERENCES
        IndexedProperty(IndexedProperty&& other)
          : SearchTerm(std::move(other.SearchTerm)),
            Value(std::move(other.Value)),
            Conditionals(std::move(other.Conditionals))
        {
        }
#endif
        
        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated operator= OK
        IndexedProperty& operator=(const IndexedProperty& other) = default;
#endif

        bool operator==(const IndexedProperty& other) const
        {
            return true
                && (SearchTerm == other.SearchTerm)
                && (Value == other.Value)
                && (Conditionals == other.Conditionals);
        }

        bool operator!=(const IndexedProperty& other) const
        {
            return !(*this == other);
        }

        void swap(IndexedProperty& other)
        {
            using std::swap;
            swap(SearchTerm, other.SearchTerm);
            swap(Value, other.Value);
            swap(Conditionals, other.Conditionals);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(IndexedProperty& left, IndexedProperty& right)
    {
        left.swap(right);
    }

    
    struct IndexSearch
    {
        std::vector< ::HealthCare::Schemas::Index::IndexedProperty> SearchTerms;
        bond::nullable<bond::bonded< ::HealthCare::Schemas::Index::ViewCollection> > View;
        
        IndexSearch()
        {
        }

        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated copy ctor OK
        IndexSearch(const IndexSearch& other) = default;
#endif
        
#ifndef BOND_NO_CXX11_RVALUE_REFERENCES
        IndexSearch(IndexSearch&& other)
          : SearchTerms(std::move(other.SearchTerms)),
            View(std::move(other.View))
        {
        }
#endif
        
        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated operator= OK
        IndexSearch& operator=(const IndexSearch& other) = default;
#endif

        bool operator==(const IndexSearch& other) const
        {
            return true
                && (SearchTerms == other.SearchTerms)
                && (View == other.View);
        }

        bool operator!=(const IndexSearch& other) const
        {
            return !(*this == other);
        }

        void swap(IndexSearch& other)
        {
            using std::swap;
            swap(SearchTerms, other.SearchTerms);
            swap(View, other.View);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(IndexSearch& left, IndexSearch& right)
    {
        left.swap(right);
    }

    
    struct ViewCollection
    {
        std::vector<std::string> ViewFields;
        
        ViewCollection()
        {
        }

        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated copy ctor OK
        ViewCollection(const ViewCollection& other) = default;
#endif
        
#ifndef BOND_NO_CXX11_RVALUE_REFERENCES
        ViewCollection(ViewCollection&& other)
          : ViewFields(std::move(other.ViewFields))
        {
        }
#endif
        
        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated operator= OK
        ViewCollection& operator=(const ViewCollection& other) = default;
#endif

        bool operator==(const ViewCollection& other) const
        {
            return true
                && (ViewFields == other.ViewFields);
        }

        bool operator!=(const ViewCollection& other) const
        {
            return !(*this == other);
        }

        void swap(ViewCollection& other)
        {
            using std::swap;
            swap(ViewFields, other.ViewFields);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(ViewCollection& left, ViewCollection& right)
    {
        left.swap(right);
    }
} // namespace Index
} // namespace Schemas
} // namespace HealthCare

