
//------------------------------------------------------------------------------
// This code was generated by a tool.
//
//   Tool : Bond Compiler 0.3.0.5
//   File : UserSchema_types.h
//
// Changes to this file may cause incorrect behavior and will be lost when
// the code is regenerated.
// <auto-generated />
//------------------------------------------------------------------------------

#pragma once

#include <bond/core/bond_version.h>

#if BOND_VERSION < 0x302
#error This file was generated by a newer version of Bond compiler
#error and is incompatible with your version Bond library.
#endif

#if BOND_MIN_CODEGEN_VERSION > 0x0305
#error This file was generated by an older version of Bond compiler
#error and is incompatible with your version Bond library.
#endif

#include <bond/core/config.h>
#include <bond/core/containers.h>
#include <bond/core/nullable.h>
#include <bond/core/bonded.h>

#include "BaseClasses_types.h"
#include "BasePerson_types.h"

namespace HealthCare
{
namespace Schemas
{
    
    namespace _bond_enumerators
    {
    namespace FeedbackType
    {
        enum FeedbackType
        {
            Positive,
            Neutral,
            Negative
        };
        
        extern const std::map<enum FeedbackType, std::string> _value_to_name_FeedbackType;
        extern const std::map<std::string, enum FeedbackType> _name_to_value_FeedbackType;

        inline
        const char* GetTypeName(enum FeedbackType)
        {
            return "FeedbackType";
        }

        inline
        const char* GetTypeName(enum FeedbackType, const bond::qualified_name_tag&)
        {
            return "HealthCare.Schemas.FeedbackType";
        }

        inline
        const std::map<enum FeedbackType, std::string>& GetValueToNameMap(enum FeedbackType)
        {
            return _value_to_name_FeedbackType;
        }

        inline
        const std::map<std::string, enum FeedbackType>& GetNameToValueMap(enum FeedbackType)
        {
            return _name_to_value_FeedbackType;
        }

        const std::string& ToString(enum FeedbackType value);

        void FromString(const std::string& name, enum FeedbackType& value);

        inline
        bool ToEnum(enum FeedbackType& value, const std::string& name)
        {
            std::map<std::string, enum FeedbackType>::const_iterator it =
                _name_to_value_FeedbackType.find(name);

            if (_name_to_value_FeedbackType.end() == it)
                return false;

            value = it->second;

            return true;
        }
    } // namespace FeedbackType
    } // namespace _bond_enumerators

    using namespace _bond_enumerators::FeedbackType;
    

    
    namespace _bond_enumerators
    {
    namespace FeedbackStatus
    {
        enum FeedbackStatus
        {
            Draft,
            Submitted
        };
        
        extern const std::map<enum FeedbackStatus, std::string> _value_to_name_FeedbackStatus;
        extern const std::map<std::string, enum FeedbackStatus> _name_to_value_FeedbackStatus;

        inline
        const char* GetTypeName(enum FeedbackStatus)
        {
            return "FeedbackStatus";
        }

        inline
        const char* GetTypeName(enum FeedbackStatus, const bond::qualified_name_tag&)
        {
            return "HealthCare.Schemas.FeedbackStatus";
        }

        inline
        const std::map<enum FeedbackStatus, std::string>& GetValueToNameMap(enum FeedbackStatus)
        {
            return _value_to_name_FeedbackStatus;
        }

        inline
        const std::map<std::string, enum FeedbackStatus>& GetNameToValueMap(enum FeedbackStatus)
        {
            return _name_to_value_FeedbackStatus;
        }

        const std::string& ToString(enum FeedbackStatus value);

        void FromString(const std::string& name, enum FeedbackStatus& value);

        inline
        bool ToEnum(enum FeedbackStatus& value, const std::string& name)
        {
            std::map<std::string, enum FeedbackStatus>::const_iterator it =
                _name_to_value_FeedbackStatus.find(name);

            if (_name_to_value_FeedbackStatus.end() == it)
                return false;

            value = it->second;

            return true;
        }
    } // namespace FeedbackStatus
    } // namespace _bond_enumerators

    using namespace _bond_enumerators::FeedbackStatus;
    

    
    struct Preference
      : ::HealthCare::Schemas::BaseItem
    {
        bond::maybe<bond::nullable<std::string> > Key;
        bond::maybe<bond::nullable<std::string> > Value;
        
        Preference()
        {
        }

        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated copy ctor OK
        Preference(const Preference& other) = default;
#endif
        
#ifndef BOND_NO_CXX11_RVALUE_REFERENCES
        Preference(Preference&& other)
          : ::HealthCare::Schemas::BaseItem(std::move(other)),
            Key(std::move(other.Key)),
            Value(std::move(other.Value))
        {
        }
#endif
        
        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated operator= OK
        Preference& operator=(const Preference& other) = default;
#endif

        bool operator==(const Preference& other) const
        {
            return true
                && (static_cast<const ::HealthCare::Schemas::BaseItem&>(*this) == static_cast<const ::HealthCare::Schemas::BaseItem&>( other))
                && (Key == other.Key)
                && (Value == other.Value);
        }

        bool operator!=(const Preference& other) const
        {
            return !(*this == other);
        }

        void swap(Preference& other)
        {
            using std::swap;
            ::HealthCare::Schemas::BaseItem::swap( other);
            swap(Key, other.Key);
            swap(Value, other.Value);
        }

        struct Schema;

    protected:
        void InitMetadata(const char* name, const char* qualified_name)
        {
            ::HealthCare::Schemas::BaseItem::InitMetadata(name, qualified_name);
        }
    };

    inline void swap(Preference& left, Preference& right)
    {
        left.swap(right);
    }

    
    struct Feedback
      : ::HealthCare::Schemas::BaseItem
    {
        bond::maybe<bond::nullable< ::HealthCare::Schemas::FeedbackType> > Type;
        bond::maybe<bond::nullable<std::string> > Text;
        bond::maybe<bond::nullable<std::string> > PageName;
        bond::maybe<bond::nullable<bool> > IsPageInfoIncluded;
        bond::maybe<bond::nullable<bool> > IsUserInfoIncluded;
        bond::maybe<bond::nullable< ::HealthCare::Schemas::FeedbackStatus> > Status;
        
        Feedback()
        {
        }

        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated copy ctor OK
        Feedback(const Feedback& other) = default;
#endif
        
#ifndef BOND_NO_CXX11_RVALUE_REFERENCES
        Feedback(Feedback&& other)
          : ::HealthCare::Schemas::BaseItem(std::move(other)),
            Type(std::move(other.Type)),
            Text(std::move(other.Text)),
            PageName(std::move(other.PageName)),
            IsPageInfoIncluded(std::move(other.IsPageInfoIncluded)),
            IsUserInfoIncluded(std::move(other.IsUserInfoIncluded)),
            Status(std::move(other.Status))
        {
        }
#endif
        
        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated operator= OK
        Feedback& operator=(const Feedback& other) = default;
#endif

        bool operator==(const Feedback& other) const
        {
            return true
                && (static_cast<const ::HealthCare::Schemas::BaseItem&>(*this) == static_cast<const ::HealthCare::Schemas::BaseItem&>( other))
                && (Type == other.Type)
                && (Text == other.Text)
                && (PageName == other.PageName)
                && (IsPageInfoIncluded == other.IsPageInfoIncluded)
                && (IsUserInfoIncluded == other.IsUserInfoIncluded)
                && (Status == other.Status);
        }

        bool operator!=(const Feedback& other) const
        {
            return !(*this == other);
        }

        void swap(Feedback& other)
        {
            using std::swap;
            ::HealthCare::Schemas::BaseItem::swap( other);
            swap(Type, other.Type);
            swap(Text, other.Text);
            swap(PageName, other.PageName);
            swap(IsPageInfoIncluded, other.IsPageInfoIncluded);
            swap(IsUserInfoIncluded, other.IsUserInfoIncluded);
            swap(Status, other.Status);
        }

        struct Schema;

    protected:
        void InitMetadata(const char* name, const char* qualified_name)
        {
            ::HealthCare::Schemas::BaseItem::InitMetadata(name, qualified_name);
        }
    };

    inline void swap(Feedback& left, Feedback& right)
    {
        left.swap(right);
    }

    
    namespace _bond_enumerators
    {
    namespace UserType
    {
        enum UserType
        {
            FrontOffice = 0,
            MedicalStaff = 1,
            Provider = 2
        };
        
        extern const std::map<enum UserType, std::string> _value_to_name_UserType;
        extern const std::map<std::string, enum UserType> _name_to_value_UserType;

        inline
        const char* GetTypeName(enum UserType)
        {
            return "UserType";
        }

        inline
        const char* GetTypeName(enum UserType, const bond::qualified_name_tag&)
        {
            return "HealthCare.Schemas.UserType";
        }

        inline
        const std::map<enum UserType, std::string>& GetValueToNameMap(enum UserType)
        {
            return _value_to_name_UserType;
        }

        inline
        const std::map<std::string, enum UserType>& GetNameToValueMap(enum UserType)
        {
            return _name_to_value_UserType;
        }

        const std::string& ToString(enum UserType value);

        void FromString(const std::string& name, enum UserType& value);

        inline
        bool ToEnum(enum UserType& value, const std::string& name)
        {
            std::map<std::string, enum UserType>::const_iterator it =
                _name_to_value_UserType.find(name);

            if (_name_to_value_UserType.end() == it)
                return false;

            value = it->second;

            return true;
        }
    } // namespace UserType
    } // namespace _bond_enumerators

    using namespace _bond_enumerators::UserType;
    

    
    struct User
      : ::HealthCare::Schemas::BasePerson
    {
        bond::nullable<bond::bonded< ::HealthCare::Schemas::BaseItemCollection< ::HealthCare::Schemas::Preference> > > Preferences;
        bond::nullable<bond::bonded< ::HealthCare::Schemas::BaseItemCollection< ::HealthCare::Schemas::Feedback> > > Feedback;
        bond::maybe<bond::nullable< ::HealthCare::Schemas::UserType> > UserType;
        
        User()
        {
        }

        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated copy ctor OK
        User(const User& other) = default;
#endif
        
#ifndef BOND_NO_CXX11_RVALUE_REFERENCES
        User(User&& other)
          : ::HealthCare::Schemas::BasePerson(std::move(other)),
            Preferences(std::move(other.Preferences)),
            Feedback(std::move(other.Feedback)),
            UserType(std::move(other.UserType))
        {
        }
#endif
        
        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated operator= OK
        User& operator=(const User& other) = default;
#endif

        bool operator==(const User& other) const
        {
            return true
                && (static_cast<const ::HealthCare::Schemas::BasePerson&>(*this) == static_cast<const ::HealthCare::Schemas::BasePerson&>( other))
                && (Preferences == other.Preferences)
                && (Feedback == other.Feedback)
                && (UserType == other.UserType);
        }

        bool operator!=(const User& other) const
        {
            return !(*this == other);
        }

        void swap(User& other)
        {
            using std::swap;
            ::HealthCare::Schemas::BasePerson::swap( other);
            swap(Preferences, other.Preferences);
            swap(Feedback, other.Feedback);
            swap(UserType, other.UserType);
        }

        struct Schema;

    protected:
        void InitMetadata(const char* name, const char* qualified_name)
        {
            ::HealthCare::Schemas::BasePerson::InitMetadata(name, qualified_name);
        }
    };

    inline void swap(User& left, User& right)
    {
        left.swap(right);
    }
} // namespace Schemas
} // namespace HealthCare

