
//------------------------------------------------------------------------------
// This code was generated by a tool.
//
//   Tool : Bond Compiler 0.3.0.5
//   File : BaseObservationSet_types.h
//
// Changes to this file may cause incorrect behavior and will be lost when
// the code is regenerated.
// <auto-generated />
//------------------------------------------------------------------------------

#pragma once

#include <bond/core/bond_version.h>

#if BOND_VERSION < 0x302
#error This file was generated by a newer version of Bond compiler
#error and is incompatible with your version Bond library.
#endif

#if BOND_MIN_CODEGEN_VERSION > 0x0305
#error This file was generated by an older version of Bond compiler
#error and is incompatible with your version Bond library.
#endif

#include <bond/core/config.h>
#include <bond/core/containers.h>


#include "BaseClasses_types.h"
#include "BaseObservation_types.h"

namespace HealthCare
{
namespace Schemas
{
    
    struct ObsCatalogSetItem
    {
        bond::maybe<bond::nullable<std::string> > ObsName;
        bond::maybe<bond::nullable<int16_t> > DisplaySequence;
        bond::maybe<bond::nullable<int16_t> > IsActive;
        bond::maybe<bond::nullable<double> > PWItemType;
        bond::maybe<bond::nullable<int16_t> > PWNewParagraph;
        bond::maybe<bond::nullable<std::string> > PWStatementDesc;
        bond::maybe<bond::nullable<std::string> > ObsCatalogSetName;
        bond::maybe<bond::nullable<int16_t> > ItemLineNo;
        bond::maybe<bond::nullable<int16_t> > ItemPosition;
        bond::maybe<bond::nullable<std::string> > ItemSeparator;
        bond::maybe<bond::nullable<int16_t> > CellColumnIndex;
        bond::maybe<bond::nullable<int16_t> > CellRowIndex;
        bond::maybe<bond::nullable<int16_t> > CellRowSpan;
        bond::maybe<bond::nullable<int16_t> > CellColumnSpan;
        bond::maybe<bond::nullable<double> > ResultGridPosition;
        bond::maybe<bond::nullable<std::string> > DisplayRowLabel;
        bond::maybe<bond::nullable< ::HealthCare::Schemas::ObservationDescription> > ObservationDescription;
        
        ObsCatalogSetItem()
        {
        }

        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated copy ctor OK
        ObsCatalogSetItem(const ObsCatalogSetItem& other) = default;
#endif
        
#ifndef BOND_NO_CXX11_RVALUE_REFERENCES
        ObsCatalogSetItem(ObsCatalogSetItem&& other)
          : ObsName(std::move(other.ObsName)),
            DisplaySequence(std::move(other.DisplaySequence)),
            IsActive(std::move(other.IsActive)),
            PWItemType(std::move(other.PWItemType)),
            PWNewParagraph(std::move(other.PWNewParagraph)),
            PWStatementDesc(std::move(other.PWStatementDesc)),
            ObsCatalogSetName(std::move(other.ObsCatalogSetName)),
            ItemLineNo(std::move(other.ItemLineNo)),
            ItemPosition(std::move(other.ItemPosition)),
            ItemSeparator(std::move(other.ItemSeparator)),
            CellColumnIndex(std::move(other.CellColumnIndex)),
            CellRowIndex(std::move(other.CellRowIndex)),
            CellRowSpan(std::move(other.CellRowSpan)),
            CellColumnSpan(std::move(other.CellColumnSpan)),
            ResultGridPosition(std::move(other.ResultGridPosition)),
            DisplayRowLabel(std::move(other.DisplayRowLabel)),
            ObservationDescription(std::move(other.ObservationDescription))
        {
        }
#endif
        
        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated operator= OK
        ObsCatalogSetItem& operator=(const ObsCatalogSetItem& other) = default;
#endif

        bool operator==(const ObsCatalogSetItem& other) const
        {
            return true
                && (ObsName == other.ObsName)
                && (DisplaySequence == other.DisplaySequence)
                && (IsActive == other.IsActive)
                && (PWItemType == other.PWItemType)
                && (PWNewParagraph == other.PWNewParagraph)
                && (PWStatementDesc == other.PWStatementDesc)
                && (ObsCatalogSetName == other.ObsCatalogSetName)
                && (ItemLineNo == other.ItemLineNo)
                && (ItemPosition == other.ItemPosition)
                && (ItemSeparator == other.ItemSeparator)
                && (CellColumnIndex == other.CellColumnIndex)
                && (CellRowIndex == other.CellRowIndex)
                && (CellRowSpan == other.CellRowSpan)
                && (CellColumnSpan == other.CellColumnSpan)
                && (ResultGridPosition == other.ResultGridPosition)
                && (DisplayRowLabel == other.DisplayRowLabel)
                && (ObservationDescription == other.ObservationDescription);
        }

        bool operator!=(const ObsCatalogSetItem& other) const
        {
            return !(*this == other);
        }

        void swap(ObsCatalogSetItem& other)
        {
            using std::swap;
            swap(ObsName, other.ObsName);
            swap(DisplaySequence, other.DisplaySequence);
            swap(IsActive, other.IsActive);
            swap(PWItemType, other.PWItemType);
            swap(PWNewParagraph, other.PWNewParagraph);
            swap(PWStatementDesc, other.PWStatementDesc);
            swap(ObsCatalogSetName, other.ObsCatalogSetName);
            swap(ItemLineNo, other.ItemLineNo);
            swap(ItemPosition, other.ItemPosition);
            swap(ItemSeparator, other.ItemSeparator);
            swap(CellColumnIndex, other.CellColumnIndex);
            swap(CellRowIndex, other.CellRowIndex);
            swap(CellRowSpan, other.CellRowSpan);
            swap(CellColumnSpan, other.CellColumnSpan);
            swap(ResultGridPosition, other.ResultGridPosition);
            swap(DisplayRowLabel, other.DisplayRowLabel);
            swap(ObservationDescription, other.ObservationDescription);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(ObsCatalogSetItem& left, ObsCatalogSetItem& right)
    {
        left.swap(right);
    }

    
    struct ObservationSetDescription
      : ::HealthCare::Schemas::BaseEntity
    {
        bond::maybe<bond::nullable<std::string> > Name;
        bond::maybe<bond::nullable<std::string> > Description;
        bond::maybe<bond::nullable<int64_t> > EffectiveDate;
        bond::maybe<bond::nullable<int64_t> > ExpiryDate;
        bond::maybe<bond::nullable<std::string> > DisplayName;
        bond::maybe<bond::nullable<int16_t> > IsGrouped;
        bond::maybe<bond::nullable<std::string> > ObsSetType;
        bond::maybe<bond::nullable<int16_t> > IsBorderOn;
        bond::maybe<bond::nullable<int16_t> > IsDisplayRTFAsGrid;
        bond::maybe<bond::nullable<int16_t> > ObservationResultGridType;
        bond::maybe<bond::nullable<int16_t> > IsRTFBullet;
        bond::maybe<bond::nullable<int16_t> > IsRTFConcatenate;
        bond::maybe<std::vector< ::HealthCare::Schemas::ObsCatalogSetItem> > ObsSetItems;
        
        ObservationSetDescription()
        {
        }

        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated copy ctor OK
        ObservationSetDescription(const ObservationSetDescription& other) = default;
#endif
        
#ifndef BOND_NO_CXX11_RVALUE_REFERENCES
        ObservationSetDescription(ObservationSetDescription&& other)
          : ::HealthCare::Schemas::BaseEntity(std::move(other)),
            Name(std::move(other.Name)),
            Description(std::move(other.Description)),
            EffectiveDate(std::move(other.EffectiveDate)),
            ExpiryDate(std::move(other.ExpiryDate)),
            DisplayName(std::move(other.DisplayName)),
            IsGrouped(std::move(other.IsGrouped)),
            ObsSetType(std::move(other.ObsSetType)),
            IsBorderOn(std::move(other.IsBorderOn)),
            IsDisplayRTFAsGrid(std::move(other.IsDisplayRTFAsGrid)),
            ObservationResultGridType(std::move(other.ObservationResultGridType)),
            IsRTFBullet(std::move(other.IsRTFBullet)),
            IsRTFConcatenate(std::move(other.IsRTFConcatenate)),
            ObsSetItems(std::move(other.ObsSetItems))
        {
        }
#endif
        
        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated operator= OK
        ObservationSetDescription& operator=(const ObservationSetDescription& other) = default;
#endif

        bool operator==(const ObservationSetDescription& other) const
        {
            return true
                && (static_cast<const ::HealthCare::Schemas::BaseEntity&>(*this) == static_cast<const ::HealthCare::Schemas::BaseEntity&>( other))
                && (Name == other.Name)
                && (Description == other.Description)
                && (EffectiveDate == other.EffectiveDate)
                && (ExpiryDate == other.ExpiryDate)
                && (DisplayName == other.DisplayName)
                && (IsGrouped == other.IsGrouped)
                && (ObsSetType == other.ObsSetType)
                && (IsBorderOn == other.IsBorderOn)
                && (IsDisplayRTFAsGrid == other.IsDisplayRTFAsGrid)
                && (ObservationResultGridType == other.ObservationResultGridType)
                && (IsRTFBullet == other.IsRTFBullet)
                && (IsRTFConcatenate == other.IsRTFConcatenate)
                && (ObsSetItems == other.ObsSetItems);
        }

        bool operator!=(const ObservationSetDescription& other) const
        {
            return !(*this == other);
        }

        void swap(ObservationSetDescription& other)
        {
            using std::swap;
            ::HealthCare::Schemas::BaseEntity::swap( other);
            swap(Name, other.Name);
            swap(Description, other.Description);
            swap(EffectiveDate, other.EffectiveDate);
            swap(ExpiryDate, other.ExpiryDate);
            swap(DisplayName, other.DisplayName);
            swap(IsGrouped, other.IsGrouped);
            swap(ObsSetType, other.ObsSetType);
            swap(IsBorderOn, other.IsBorderOn);
            swap(IsDisplayRTFAsGrid, other.IsDisplayRTFAsGrid);
            swap(ObservationResultGridType, other.ObservationResultGridType);
            swap(IsRTFBullet, other.IsRTFBullet);
            swap(IsRTFConcatenate, other.IsRTFConcatenate);
            swap(ObsSetItems, other.ObsSetItems);
        }

        struct Schema;

    protected:
        void InitMetadata(const char* name, const char* qualified_name)
        {
            ::HealthCare::Schemas::BaseEntity::InitMetadata(name, qualified_name);
        }
    };

    inline void swap(ObservationSetDescription& left, ObservationSetDescription& right)
    {
        left.swap(right);
    }
} // namespace Schemas
} // namespace HealthCare

