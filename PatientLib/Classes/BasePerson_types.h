
//------------------------------------------------------------------------------
// This code was generated by a tool.
//
//   Tool : Bond Compiler 0.3.0.5
//   File : BasePerson_types.h
//
// Changes to this file may cause incorrect behavior and will be lost when
// the code is regenerated.
// <auto-generated />
//------------------------------------------------------------------------------

#pragma once

#include <bond/core/bond_version.h>

#if BOND_VERSION < 0x302
#error This file was generated by a newer version of Bond compiler
#error and is incompatible with your version Bond library.
#endif

#if BOND_MIN_CODEGEN_VERSION > 0x0305
#error This file was generated by an older version of Bond compiler
#error and is incompatible with your version Bond library.
#endif

#include <bond/core/config.h>
#include <bond/core/containers.h>
#include <bond/core/nullable.h>
#include <bond/core/bonded.h>

#include "BaseClasses_types.h"
#include "ImageResource_types.h"

namespace HealthCare
{
namespace Schemas
{
    
    namespace _bond_enumerators
    {
    namespace RaceFlag
    {
        enum RaceFlag
        {
            _Blank,
            AmericanIndianOrAlaskaNative,
            Asian,
            Black,
            Hispanic,
            PacificIslander,
            Unknown,
            Unspecified,
            White
        };
        
        extern const std::map<enum RaceFlag, std::string> _value_to_name_RaceFlag;
        extern const std::map<std::string, enum RaceFlag> _name_to_value_RaceFlag;

        inline
        const char* GetTypeName(enum RaceFlag)
        {
            return "RaceFlag";
        }

        inline
        const char* GetTypeName(enum RaceFlag, const bond::qualified_name_tag&)
        {
            return "HealthCare.Schemas.RaceFlag";
        }

        inline
        const std::map<enum RaceFlag, std::string>& GetValueToNameMap(enum RaceFlag)
        {
            return _value_to_name_RaceFlag;
        }

        inline
        const std::map<std::string, enum RaceFlag>& GetNameToValueMap(enum RaceFlag)
        {
            return _name_to_value_RaceFlag;
        }

        const std::string& ToString(enum RaceFlag value);

        void FromString(const std::string& name, enum RaceFlag& value);

        inline
        bool ToEnum(enum RaceFlag& value, const std::string& name)
        {
            std::map<std::string, enum RaceFlag>::const_iterator it =
                _name_to_value_RaceFlag.find(name);

            if (_name_to_value_RaceFlag.end() == it)
                return false;

            value = it->second;

            return true;
        }
    } // namespace RaceFlag
    } // namespace _bond_enumerators

    using namespace _bond_enumerators::RaceFlag;
    

    
    namespace _bond_enumerators
    {
    namespace EthnicityFlag
    {
        enum EthnicityFlag
        {
            _Blank,
            Hispanic,
            NonHispanic,
            Unknown,
            Unspecified
        };
        
        extern const std::map<enum EthnicityFlag, std::string> _value_to_name_EthnicityFlag;
        extern const std::map<std::string, enum EthnicityFlag> _name_to_value_EthnicityFlag;

        inline
        const char* GetTypeName(enum EthnicityFlag)
        {
            return "EthnicityFlag";
        }

        inline
        const char* GetTypeName(enum EthnicityFlag, const bond::qualified_name_tag&)
        {
            return "HealthCare.Schemas.EthnicityFlag";
        }

        inline
        const std::map<enum EthnicityFlag, std::string>& GetValueToNameMap(enum EthnicityFlag)
        {
            return _value_to_name_EthnicityFlag;
        }

        inline
        const std::map<std::string, enum EthnicityFlag>& GetNameToValueMap(enum EthnicityFlag)
        {
            return _name_to_value_EthnicityFlag;
        }

        const std::string& ToString(enum EthnicityFlag value);

        void FromString(const std::string& name, enum EthnicityFlag& value);

        inline
        bool ToEnum(enum EthnicityFlag& value, const std::string& name)
        {
            std::map<std::string, enum EthnicityFlag>::const_iterator it =
                _name_to_value_EthnicityFlag.find(name);

            if (_name_to_value_EthnicityFlag.end() == it)
                return false;

            value = it->second;

            return true;
        }
    } // namespace EthnicityFlag
    } // namespace _bond_enumerators

    using namespace _bond_enumerators::EthnicityFlag;
    

    
    namespace _bond_enumerators
    {
    namespace Gender
    {
        enum Gender
        {
            Unspecified,
            Male,
            Female
        };
        
        extern const std::map<enum Gender, std::string> _value_to_name_Gender;
        extern const std::map<std::string, enum Gender> _name_to_value_Gender;

        inline
        const char* GetTypeName(enum Gender)
        {
            return "Gender";
        }

        inline
        const char* GetTypeName(enum Gender, const bond::qualified_name_tag&)
        {
            return "HealthCare.Schemas.Gender";
        }

        inline
        const std::map<enum Gender, std::string>& GetValueToNameMap(enum Gender)
        {
            return _value_to_name_Gender;
        }

        inline
        const std::map<std::string, enum Gender>& GetNameToValueMap(enum Gender)
        {
            return _name_to_value_Gender;
        }

        const std::string& ToString(enum Gender value);

        void FromString(const std::string& name, enum Gender& value);

        inline
        bool ToEnum(enum Gender& value, const std::string& name)
        {
            std::map<std::string, enum Gender>::const_iterator it =
                _name_to_value_Gender.find(name);

            if (_name_to_value_Gender.end() == it)
                return false;

            value = it->second;

            return true;
        }
    } // namespace Gender
    } // namespace _bond_enumerators

    using namespace _bond_enumerators::Gender;
    

    
    namespace _bond_enumerators
    {
    namespace TelephoneNumberKind
    {
        enum TelephoneNumberKind
        {
            NANP
        };
        
        extern const std::map<enum TelephoneNumberKind, std::string> _value_to_name_TelephoneNumberKind;
        extern const std::map<std::string, enum TelephoneNumberKind> _name_to_value_TelephoneNumberKind;

        inline
        const char* GetTypeName(enum TelephoneNumberKind)
        {
            return "TelephoneNumberKind";
        }

        inline
        const char* GetTypeName(enum TelephoneNumberKind, const bond::qualified_name_tag&)
        {
            return "HealthCare.Schemas.TelephoneNumberKind";
        }

        inline
        const std::map<enum TelephoneNumberKind, std::string>& GetValueToNameMap(enum TelephoneNumberKind)
        {
            return _value_to_name_TelephoneNumberKind;
        }

        inline
        const std::map<std::string, enum TelephoneNumberKind>& GetNameToValueMap(enum TelephoneNumberKind)
        {
            return _name_to_value_TelephoneNumberKind;
        }

        const std::string& ToString(enum TelephoneNumberKind value);

        void FromString(const std::string& name, enum TelephoneNumberKind& value);

        inline
        bool ToEnum(enum TelephoneNumberKind& value, const std::string& name)
        {
            std::map<std::string, enum TelephoneNumberKind>::const_iterator it =
                _name_to_value_TelephoneNumberKind.find(name);

            if (_name_to_value_TelephoneNumberKind.end() == it)
                return false;

            value = it->second;

            return true;
        }
    } // namespace TelephoneNumberKind
    } // namespace _bond_enumerators

    using namespace _bond_enumerators::TelephoneNumberKind;
    

    
    struct PersonName
    {
        bond::maybe<bond::nullable<std::string> > FirstName;
        bond::maybe<bond::nullable<std::string> > LastName;
        bond::maybe<bond::nullable<std::string> > MiddleName;
        bond::maybe<bond::nullable<std::string> > Suffix;
        bond::maybe<bond::nullable<std::string> > Credentials;
        bond::maybe<bond::nullable<std::string> > Salutation;
        bond::maybe<bond::nullable<std::string> > Nickname;
        
        PersonName()
        {
        }

        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated copy ctor OK
        PersonName(const PersonName& other) = default;
#endif
        
#ifndef BOND_NO_CXX11_RVALUE_REFERENCES
        PersonName(PersonName&& other)
          : FirstName(std::move(other.FirstName)),
            LastName(std::move(other.LastName)),
            MiddleName(std::move(other.MiddleName)),
            Suffix(std::move(other.Suffix)),
            Credentials(std::move(other.Credentials)),
            Salutation(std::move(other.Salutation)),
            Nickname(std::move(other.Nickname))
        {
        }
#endif
        
        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated operator= OK
        PersonName& operator=(const PersonName& other) = default;
#endif

        bool operator==(const PersonName& other) const
        {
            return true
                && (FirstName == other.FirstName)
                && (LastName == other.LastName)
                && (MiddleName == other.MiddleName)
                && (Suffix == other.Suffix)
                && (Credentials == other.Credentials)
                && (Salutation == other.Salutation)
                && (Nickname == other.Nickname);
        }

        bool operator!=(const PersonName& other) const
        {
            return !(*this == other);
        }

        void swap(PersonName& other)
        {
            using std::swap;
            swap(FirstName, other.FirstName);
            swap(LastName, other.LastName);
            swap(MiddleName, other.MiddleName);
            swap(Suffix, other.Suffix);
            swap(Credentials, other.Credentials);
            swap(Salutation, other.Salutation);
            swap(Nickname, other.Nickname);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(PersonName& left, PersonName& right)
    {
        left.swap(right);
    }

    
    struct Address
    {
        bond::maybe<bond::nullable<std::string> > Line1;
        bond::maybe<bond::nullable<std::string> > Line2;
        bond::maybe<bond::nullable<std::string> > Line3;
        bond::maybe<bond::nullable<std::string> > City;
        bond::maybe<bond::nullable<std::string> > State;
        bond::maybe<bond::nullable<std::string> > ZipCode;
        bond::maybe<bond::nullable<std::string> > Country;
        
        Address()
        {
        }

        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated copy ctor OK
        Address(const Address& other) = default;
#endif
        
#ifndef BOND_NO_CXX11_RVALUE_REFERENCES
        Address(Address&& other)
          : Line1(std::move(other.Line1)),
            Line2(std::move(other.Line2)),
            Line3(std::move(other.Line3)),
            City(std::move(other.City)),
            State(std::move(other.State)),
            ZipCode(std::move(other.ZipCode)),
            Country(std::move(other.Country))
        {
        }
#endif
        
        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated operator= OK
        Address& operator=(const Address& other) = default;
#endif

        bool operator==(const Address& other) const
        {
            return true
                && (Line1 == other.Line1)
                && (Line2 == other.Line2)
                && (Line3 == other.Line3)
                && (City == other.City)
                && (State == other.State)
                && (ZipCode == other.ZipCode)
                && (Country == other.Country);
        }

        bool operator!=(const Address& other) const
        {
            return !(*this == other);
        }

        void swap(Address& other)
        {
            using std::swap;
            swap(Line1, other.Line1);
            swap(Line2, other.Line2);
            swap(Line3, other.Line3);
            swap(City, other.City);
            swap(State, other.State);
            swap(ZipCode, other.ZipCode);
            swap(Country, other.Country);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(Address& left, Address& right)
    {
        left.swap(right);
    }

    
    struct TelephoneNumber
    {
        bond::maybe<bond::nullable<int16_t> > CountryCode;
        bond::maybe<bond::nullable<std::string> > Number;
        bond::maybe<bond::nullable<std::string> > Ext;
        bond::maybe<bond::nullable< ::HealthCare::Schemas::TelephoneNumberKind> > Kind;
        
        TelephoneNumber()
        {
        }

        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated copy ctor OK
        TelephoneNumber(const TelephoneNumber& other) = default;
#endif
        
#ifndef BOND_NO_CXX11_RVALUE_REFERENCES
        TelephoneNumber(TelephoneNumber&& other)
          : CountryCode(std::move(other.CountryCode)),
            Number(std::move(other.Number)),
            Ext(std::move(other.Ext)),
            Kind(std::move(other.Kind))
        {
        }
#endif
        
        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated operator= OK
        TelephoneNumber& operator=(const TelephoneNumber& other) = default;
#endif

        bool operator==(const TelephoneNumber& other) const
        {
            return true
                && (CountryCode == other.CountryCode)
                && (Number == other.Number)
                && (Ext == other.Ext)
                && (Kind == other.Kind);
        }

        bool operator!=(const TelephoneNumber& other) const
        {
            return !(*this == other);
        }

        void swap(TelephoneNumber& other)
        {
            using std::swap;
            swap(CountryCode, other.CountryCode);
            swap(Number, other.Number);
            swap(Ext, other.Ext);
            swap(Kind, other.Kind);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(TelephoneNumber& left, TelephoneNumber& right)
    {
        left.swap(right);
    }

    
    struct PersonContactInformation
    {
        bond::maybe<bond::nullable< ::HealthCare::Schemas::Address> > MailingAddress;
        bond::maybe<bond::nullable< ::HealthCare::Schemas::TelephoneNumber> > HomeTelephoneNumber;
        bond::maybe<bond::nullable< ::HealthCare::Schemas::TelephoneNumber> > CellularTelephoneNumber;
        bond::maybe<bond::nullable< ::HealthCare::Schemas::TelephoneNumber> > WorkTelephoneNumber;
        bond::maybe<bond::nullable<std::string> > EmailAddress;
        bond::maybe<bond::nullable< ::HealthCare::Schemas::TelephoneNumber> > FaxTelephoneNumber;
        
        PersonContactInformation()
        {
        }

        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated copy ctor OK
        PersonContactInformation(const PersonContactInformation& other) = default;
#endif
        
#ifndef BOND_NO_CXX11_RVALUE_REFERENCES
        PersonContactInformation(PersonContactInformation&& other)
          : MailingAddress(std::move(other.MailingAddress)),
            HomeTelephoneNumber(std::move(other.HomeTelephoneNumber)),
            CellularTelephoneNumber(std::move(other.CellularTelephoneNumber)),
            WorkTelephoneNumber(std::move(other.WorkTelephoneNumber)),
            EmailAddress(std::move(other.EmailAddress)),
            FaxTelephoneNumber(std::move(other.FaxTelephoneNumber))
        {
        }
#endif
        
        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated operator= OK
        PersonContactInformation& operator=(const PersonContactInformation& other) = default;
#endif

        bool operator==(const PersonContactInformation& other) const
        {
            return true
                && (MailingAddress == other.MailingAddress)
                && (HomeTelephoneNumber == other.HomeTelephoneNumber)
                && (CellularTelephoneNumber == other.CellularTelephoneNumber)
                && (WorkTelephoneNumber == other.WorkTelephoneNumber)
                && (EmailAddress == other.EmailAddress)
                && (FaxTelephoneNumber == other.FaxTelephoneNumber);
        }

        bool operator!=(const PersonContactInformation& other) const
        {
            return !(*this == other);
        }

        void swap(PersonContactInformation& other)
        {
            using std::swap;
            swap(MailingAddress, other.MailingAddress);
            swap(HomeTelephoneNumber, other.HomeTelephoneNumber);
            swap(CellularTelephoneNumber, other.CellularTelephoneNumber);
            swap(WorkTelephoneNumber, other.WorkTelephoneNumber);
            swap(EmailAddress, other.EmailAddress);
            swap(FaxTelephoneNumber, other.FaxTelephoneNumber);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(PersonContactInformation& left, PersonContactInformation& right)
    {
        left.swap(right);
    }

    
    struct Demographics
    {
        bond::maybe<bond::nullable< ::HealthCare::Schemas::Gender> > Gender;
        bond::maybe<bond::nullable<std::string> > Language;
        bond::maybe<bond::nullable< ::HealthCare::Schemas::PersonContactInformation> > ContactInformation;
        bond::maybe<bond::nullable< ::HealthCare::Schemas::EthnicityFlag> > Ethnicity;
        bond::maybe<bond::nullable< ::HealthCare::Schemas::RaceFlag> > Race;
        
        Demographics()
        {
        }

        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated copy ctor OK
        Demographics(const Demographics& other) = default;
#endif
        
#ifndef BOND_NO_CXX11_RVALUE_REFERENCES
        Demographics(Demographics&& other)
          : Gender(std::move(other.Gender)),
            Language(std::move(other.Language)),
            ContactInformation(std::move(other.ContactInformation)),
            Ethnicity(std::move(other.Ethnicity)),
            Race(std::move(other.Race))
        {
        }
#endif
        
        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated operator= OK
        Demographics& operator=(const Demographics& other) = default;
#endif

        bool operator==(const Demographics& other) const
        {
            return true
                && (Gender == other.Gender)
                && (Language == other.Language)
                && (ContactInformation == other.ContactInformation)
                && (Ethnicity == other.Ethnicity)
                && (Race == other.Race);
        }

        bool operator!=(const Demographics& other) const
        {
            return !(*this == other);
        }

        void swap(Demographics& other)
        {
            using std::swap;
            swap(Gender, other.Gender);
            swap(Language, other.Language);
            swap(ContactInformation, other.ContactInformation);
            swap(Ethnicity, other.Ethnicity);
            swap(Race, other.Race);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(Demographics& left, Demographics& right)
    {
        left.swap(right);
    }

    
    struct BasePerson
      : ::HealthCare::Schemas::LocatableBaseEntity
    {
        bond::maybe<bond::nullable< ::HealthCare::Schemas::PersonName> > Name;
        bond::nullable<bond::bonded< ::HealthCare::Schemas::Demographics> > Demographics;
        bond::maybe<bond::nullable<int64_t> > DateOfBirth;
        bond::maybe<bond::nullable<int64_t> > DateOfDeath;
        std::vector< ::HealthCare::Schemas::ImageResource> ImageResources;
        
        BasePerson()
        {
        }

        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated copy ctor OK
        BasePerson(const BasePerson& other) = default;
#endif
        
#ifndef BOND_NO_CXX11_RVALUE_REFERENCES
        BasePerson(BasePerson&& other)
          : ::HealthCare::Schemas::LocatableBaseEntity(std::move(other)),
            Name(std::move(other.Name)),
            Demographics(std::move(other.Demographics)),
            DateOfBirth(std::move(other.DateOfBirth)),
            DateOfDeath(std::move(other.DateOfDeath)),
            ImageResources(std::move(other.ImageResources))
        {
        }
#endif
        
        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated operator= OK
        BasePerson& operator=(const BasePerson& other) = default;
#endif

        bool operator==(const BasePerson& other) const
        {
            return true
                && (static_cast<const ::HealthCare::Schemas::LocatableBaseEntity&>(*this) == static_cast<const ::HealthCare::Schemas::LocatableBaseEntity&>( other))
                && (Name == other.Name)
                && (Demographics == other.Demographics)
                && (DateOfBirth == other.DateOfBirth)
                && (DateOfDeath == other.DateOfDeath)
                && (ImageResources == other.ImageResources);
        }

        bool operator!=(const BasePerson& other) const
        {
            return !(*this == other);
        }

        void swap(BasePerson& other)
        {
            using std::swap;
            ::HealthCare::Schemas::LocatableBaseEntity::swap( other);
            swap(Name, other.Name);
            swap(Demographics, other.Demographics);
            swap(DateOfBirth, other.DateOfBirth);
            swap(DateOfDeath, other.DateOfDeath);
            swap(ImageResources, other.ImageResources);
        }

        struct Schema;

    protected:
        void InitMetadata(const char* name, const char* qualified_name)
        {
            ::HealthCare::Schemas::LocatableBaseEntity::InitMetadata(name, qualified_name);
        }
    };

    inline void swap(BasePerson& left, BasePerson& right)
    {
        left.swap(right);
    }
} // namespace Schemas
} // namespace HealthCare

